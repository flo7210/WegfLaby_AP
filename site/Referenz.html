<!doctype html>
<html lang="en">
<head>

<meta charset="utf-8" />
<title>Wegfindung im Labyrinth</title>
<meta name="author" content="Florian Nowak, Yichuan Shen" />
<link rel="shortcut icon" href="resources/favicon.ico" type="image/x-icon">
<link rel="stylesheet" type="text/css" href="resources/style.css" />

<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/styles/monokai_sublime.min.css">
<script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.3/highlight.min.js"></script>

<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.3.0/katex.min.css">
<script src="http://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.3.0/katex.min.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.3.0/contrib/auto-render.min.js"></script>

</head>
<body>

<header>
    <h1>Wegfindung im Labyrinth</h1>
    <nav>
        <ul>
            <li><a href="Überblick.html">Überblick</a></li>
            <li><a href="Kommunikationsprotokoll.html">Kommunikationsprotokoll</a></li>
            <li><a href="Wanderkennung.html">Wanderkennung</a></li>
            <li><a href="Referenz.html">Referenz</a></li>
            <li><a href="Ergebnis.html">Ergebnis</a></li>
        </ul>
    </nav>
</header>

<main>

<nav id="toc"></nav>

<article>
<h2 id="h2-class-maze-maze"><code>class maze.Maze</code></h2>
<p>Eine abstrakte Darstellung eines Labyrinths als rechteckiger, einfacher Graph.</p>
<h3 id="h3-__init__-width-height-"><code>__init__(width, height)</code></h3>
<p>Erstellt eine neue Instanz der Maze Klasse.</p>
<h4 id="h4-argumente">Argumente</h4>
<p>Siehe Eigenschaften.</p>
<h4 id="h4-beispiel">Beispiel</h4>
<pre><code class="python">m = Maze(5, 3)
print m

# Output:
#
# +--+--+--+--+--+
# |  |  |  |  |  |
# +--+--+--+--+--+
# |  |  |  |  |  |
# +--+--+--+--+--+
# |  |  |  |  |  |
# +--+--+--+--+--+
</code></pre>
<h3 id="h3-width"><code>width</code></h3>
<p>Die Breite des Labyrinths</p>
<h3 id="h3-height"><code>height</code></h3>
<p>Die Höhe des Labyrinths</p>
<h3 id="h3-add_edge-v1-v2-"><code>add_edge(v1, v2)</code></h3>
<p>Fügt eine Kante zwischen den Punkten <code>v1</code> und <code>v2</code> hinzu, wobei ein Punkt ein Tupel aus zwei <code>int</code> zwischen <code>1</code> und <code>width</code> bzw. <code>height</code> ist. Liegt <code>v1</code> oder <code>v2</code> nicht auf dem Graph, oder liegen <code>v1</code> und <code>v2</code> nicht nebeneinander, so wird der Befehl ignoriert.</p>
<h4 id="h4-beispiel">Beispiel</h4>
<pre><code class="python">m = Maze(5, 3)
m.add_edge((1, 1), (1, 2))
print m

# Output:
#
# +--+--+--+--+--+
# |  |  |  |  |  |
# +  +--+--+--+--+
# |  |  |  |  |  |
# +--+--+--+--+--+
# |  |  |  |  |  |
# +--+--+--+--+--+
</code></pre>
<h3 id="h3-add_path-path-"><code>add_path(path)</code></h3>
<p>Fügt Kanten entlang des Pfades <code>path</code>.</p>
<h4 id="h4-argumente">Argumente</h4>
<h5 id="h5-path-"><code>path</code>:</h5>
<p>Eine Liste von Punkten.</p>
<h4 id="h4-beispiel">Beispiel</h4>
<pre><code class="python">m = Maze(5, 3)
m.add_path([(1, 1), (1, 2), (2, 2), (3, 2), (5, 3), (5, 2)])
print m

# Output:
#
# +--+--+--+--+--+
# |  |  |  |  |  |
# +  +--+--+--+--+
# |        |  |  |
# +--+--+--+--+  +
# |  |  |  |  |  |
# +--+--+--+--+--+
</code></pre>
<h3 id="h3-bfs-start-end-"><code>bfs(start, end)</code></h3>
<p>Führt eine Breitensuche aus und gibt den kürzesten Pfad vom Punkt <code>start</code> nach <code>end</code> zurück. Ist <code>end</code> von <code>start</code> aus nicht erreichbar, so wird eine leere Liste zurückgegeben.</p>
<h3 id="h3-get_neighbors-x-y-"><code>get_neighbors(x, y)</code></h3>
<p>Gibt eine Liste von allen Punkten auf dem Graphen zurück, die genau Manhattan-Distanz <code>1</code> vom Punkt <code>(x, y)</code> entfernt sind. Ist <code>(x, y)</code> nicht auf dem Graph, so wird eine leere Liste zurückgegeben.</p>
<h3 id="h3-get_reachables-x-y-"><code>get_reachables(x, y)</code></h3>
<p>Gibt eine Liste von allen Punkten <code>v</code> in <code>get_neighbors(x, y)</code> zurück, die eine Kante nach <code>(x, y)</code> haben.</p>
<h3 id="h3-get_skippables-path-"><code>get_skippables(path)</code></h3>
<p>Gibt eine Liste von allen Indizes <code>i</code> zurück, so dass <code>[path[i - 1], path[i], path[i + 1]]</code> eine gerade Strecke bildet.</p>
<h4 id="h4-argumente">Argumente</h4>
<h5 id="h5-path-"><code>path</code>:</h5>
<p>Eine Liste von Punkten.</p>
<h4 id="h4-beispiel">Beispiel</h4>
<pre><code class="python">path = [(1, 1), (1, 2), (1, 3), (2, 3), (3, 3), (4, 3), (5, 3)]
m = Maze(5, 3)
m.add_path(path)
skippables = m.get_skippables(path)

print skippables
print m.print_path([], [path[i] for i in skippables])

# Output:
#
# [1, 3, 4, 5]
# +--+--+--+--+--+
# |  |  |  |  |  |
# +  +--+--+--+--+
# | #|  |  |  |  |
# +  +--+--+--+--+
# |    #  #  #   |
# +--+--+--+--+--+
</code></pre>
<h3 id="h3-has_vertex-x-y-"><code>has_vertex(x, y)</code></h3>
<p>Gibt ein <code>bool</code> zurück, ob sich der Punkt <code>(x, y)</code> auf dem Graph befindet, oder nicht.</p>
<h3 id="h3-has_edge-v1-v2-"><code>has_edge(v1, v2)</code></h3>
<p>Gibt ein <code>bool</code> zurück, ob die Punkte <code>v1</code> und <code>v2</code> mit einer Kante verbunden sind, oder nicht.</p>
<h3 id="h3-print_path-path-marks-"><code>print_path(path, marks = [])</code></h3>
<p>Gibt ein <code>string</code> zurück, das das Labyrinth und den angegebenen Pfad <code>path</code> repräsentiert.</p>
<h4 id="h4-argumente">Argumente</h4>
<h5 id="h5-path-"><code>path</code>:</h5>
<p>Eine Liste von Punkten. Punkte in <code>path</code> werden mit einem <code>x</code> markiert. Der letzte Punkt wird mit einem <code>(X</code> markiert.</p>
<h5 id="h5-marks-"><code>marks</code>:</h5>
<p>Eine Liste von Punkten. Punkte in <code>marks</code> werden mit einem <code>#</code> markiert.</p>
<h3 id="h3-parse-string-"><code>parse(string)</code></h3>
<p>Liest die gegebene <code>string</code> Darstellung eines Labyrinths und fügt bzw. entfernt Kanten, so dass das Objekt die Darstellung entspricht.</p>
<h4 id="h4-beispiel">Beispiel</h4>
<pre><code class="python">m = Maze(5, 3)
m.add_path([(1, 1), (1, 2), (2, 2), (3, 2), (5, 3), (5, 2)])
print m.print_path([(1, 1), (1, 2), (2, 2), (3, 2)], [(5, 1)])

# Output:
#
# +--+--+--+--+--+
# | x|  |  |  | #|
# +  +--+--+--+--+
# | x  x (X|  |  |
# +--+--+--+--+  +
# |  |  |  |  |  |
# +--+--+--+--+--+
</code></pre>
<h2 id="h2-class-balancer-balancer"><code>class balancer.Balancer</code></h2>
<p>Die Schnittstelle zwischen dem Balancierer und Python. Implementiert das <a href="Kommunikationsprotokoll">Kommunikationsprotokoll</a>.</p>
<h3 id="h3-__init__-serial-width-580-height-580-padding-25-"><code>__init__(serial, width = 580, height = 580, padding = 25)</code></h3>
<p>Erstellt eine neue Instanz der Balancer Klasse.</p>
<h4 id="h4-argumente">Argumente</h4>
<h5 id="h5-serial-"><code>serial</code>:</h5>
<p>Eine <code>serial.Serial</code> Klasse, die der Kommunikation dient.</p>
<h5 id="h5-width-"><code>width</code>:</h5>
<p>Die Breite des Touchscreens.</p>
<h5 id="h5-height-"><code>height</code>:</h5>
<p>Die Höhe des Touchscreens.</p>
<h5 id="h5-padding-"><code>padding</code>:</h5>
<p>Der Abstand vom Rand, der nicht ansteuerbar ist.</p>
<h4 id="h4-beispiel">Beispiel</h4>
<pre><code class="python">balancer = Balancer(serial.Serial(0))
balancer.serial.close()
</code></pre>
<pre><code class="python">with Balancer(serial.Serial(0)) as balancer:
    # do things
    pass
</code></pre>
<h3 id="h3-serial"><code>serial</code></h3>
<p>Die <code>serial.Serial</code> Klasse, die im Konstruktor übergeben wurde. </p>
<h3 id="h3-width"><code>width</code></h3>
<p>Die Breite des Touchscreens. <em>Standard:</em> 580</p>
<h3 id="h3-height"><code>height</code></h3>
<p>Die Höhe des Touchscreens. <em>Standard:</em> 580</p>
<h3 id="h3-padding"><code>padding</code></h3>
<p>Der Abstand vom Rand, der nicht ansteuerbar ist. <em>Standard:</em> 25</p>
<h3 id="h3-command_queue"><code>command_queue</code></h3>
<p>Eine Liste von Befehlen, die nacheinander bei der Ausführung von <code>start_listening()</code> versendet werden. Ein Befehl wird in einem Tupel <code>(force_reset, t, u)</code> gespeichert, bestehend aus einem <code>bool</code> und zwei <code>int</code>, wobei <code>t</code> die x-Koordinate und <code>u</code> die y-Koordinate bezeichnen. <code>force_reset</code> gibt an, ob die Servomotoren auf den Anfangswerten zurückgesetzt werden soll.</p>
<pre><code class="python">command = (False, 25, 100)    # entspricht dem Befehl &quot;.025,100&quot;
command = (True, 290, 290)    # entspricht dem Befehl &quot;!290,290&quot;
</code></pre>
<p><em>Standard:</em> <code>[]</code></p>
<h3 id="h3-response_handler"><code>response_handler</code></h3>
<p>Eine Funktion, die ausgeführt wird, wann immer <code>start_listening()</code> ausgeführt wird und <code>Balancer</code> eine Antwort vom Balancierer bekommt. Die Funktion soll der Form <code>response_handler(destination, response)</code> sein, wobei <code>destination = (t, u)</code> der Zielpunkt des aktuellen Befehls und <code>response = (balanced, t, u)</code> die Antwort ist, bestehend aus einem <code>bool balanced</code> und zwei <code>int</code>s.</p>
<pre><code class="python">response = (True, 25, 100)    # entspricht der Antwort &quot;=025,100&quot;
response = (False, 290, 290)  # entspricht der Antwort &quot;:290,290&quot;
</code></pre>
<p><em>Standard:</em> <code>None</code></p>
<h3 id="h3-balance_handler"><code>balance_handler</code></h3>
<p>Eine Funktion, die ausgeführt wird, wann immer <code>start_listening()</code> ausgeführt wird und die Kugel sich balanciert hat. Die Funktion soll der Form <code>balance_handler(destination, response, destination_reached)</code> sein, wobei <code>destination</code> und <code>response</code> wie in <code>response_handler</code> definiert ist und <code>destination_reached</code> ein <code>bool</code> ist, der angibt, ob die Kugel <code>destination</code> schon erreicht hat oder nicht, siehe <code>destination_reached</code> Eigenschaft.</p>
<p><em>Standard:</em> <code>None</code></p>
<h3 id="h3-destination_reached"><code>destination_reached</code></h3>
<p>Eine Funktion der Form <code>destination_reached(dest, coord)</code> die ein <code>bool</code> zurückgibt, das bestimmt, ob der angegebene Koordinatenpunkt <code>coord</code> die Zielkoordinate <code>dest</code> erreicht hat, oder nicht.</p>
<p><em>Standard:</em> <code>lambda dest, coord: self.distance(dest, coord) &lt; 15</code></p>
<h3 id="h3-add_command-t-u-force_reset-false-"><code>add_command(t, u, force_reset = False)</code></h3>
<p>Fügt ein Befehl der Form <code>(force_reset, t, u)</code> zur <code>command_queue</code> hinzu.</p>
<h4 id="h4-argumente">Argumente</h4>
<h5 id="h5-t-"><code>t</code>:</h5>
<p>Ein <code>int</code> zwischen <code>0</code> und <code>width</code>. Die x-Koordinate des Zielpunkts auf dem Touchscreen, die die Kugel ansteuern soll.</p>
<h5 id="h5-u-"><code>u</code>:</h5>
<p>Ein <code>int</code> zwischen <code>0</code> und <code>height</code>. Die y-Koordinate des Zielpunkts auf dem Touchscreen, die die Kugel ansteuern soll.</p>
<h5 id="h5-force_reset-"><code>force_reset</code>:</h5>
<p>Ein <code>bool</code>, der angibt, ob die Servomotoren auf ihre Anfangswerten zurückgesetzt werden soll oder nicht.</p>
<h3 id="h3-start_listening-"><code>start_listening()</code></h3>
<p>Verarbeitet die Befehle in <code>command_queue</code> und ruft <code>response_handler</code> bzw. <code>balance_handler</code> in den passenden Situationen auf.</p>
<h4 id="h4-beispiel">Beispiel</h4>
<pre><code class="python">with Balancer(Serial(0)) as balancer:
    def balance_handler(destination, response, destination_reached):
        if destination_reached: return
        balancer.add_command(290, 290)

    balancer.balance_handler = balance_handler
    balancer.add_command(290, 290)
    balancer.start_listening()
</code></pre>
<h3 id="h3-distance-coord1-coord2-"><code>distance(coord1, coord2)</code></h3>
<p>Berechnet die Tschebyschew-Distanz, die von der Maximumsnorm induzierte Metrik, zwischen den angegebenen Punkten und gibt diese als <code>int</code> zurück.</p>
<h4 id="h4-argumente">Argumente</h4>
<h5 id="h5-coord1-coord2-"><code>coord1</code>, <code>coord2</code>:</h5>
<p>Ein Tupel <code>(t, u)</code> aus zwei <code>int</code>.</p>
<h4 id="h4-beispiel">Beispiel</h4>
<pre><code class="python">balancer = Balancer(Serial(0))
distance = balancer.distance((100, 25), (0, 0))     # ergibt 100
</code></pre>

</article>

</main>

<footer>
<p>&copy; <a href="#">Florian Nowak</a>, <a href="#">Yichuan Shen</a> 2015</p>
</footer>

<script type="text/javascript" src="resources/site.js"></script>

</body>
</html>